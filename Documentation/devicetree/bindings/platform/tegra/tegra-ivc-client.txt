* NVIDIA Tegra IVC client driver

== IVCC device ==
Each IVCC device represents a remote processor that talks to CPU via IVC.

Required properties:
- compatible: The driver is compatible with
  "nvidia,tegra186-ivcc"

- nvidia,notifications: <HSP-phandle HSP-id HSP-doorbell>
  both HSP-id and -doorbell can be referenced by including:
    <dt-bindings/platform/t186/tegra-hsp.h>

== IVCC channel ==
Each channel is a distinct functionality that needs IPC service.
It's represented as a child node under the IVCC device node.

Required properties:

- reg: Two address entries (CPU's POV)
  * Base address and length of the write buffer
  * Base address and length of the read buffer

- nvidia,frame-size: size of the data frame, should be in range
  [4, buffer-size] and word-aligned.

== Shared memory carveout ==
All IVC headers and data channels are placed in a pre-defined known area
which is carved out away from kernel usage. This is currently done by
the /memreserve/ feature. As such, the IVC and channel reg properties must
lie within this pre-defined area.

Example:

/memreserve/ 0xa0030000 0x1000;
/memreserve/ 0xa0040000 0x1000;

ivcc@0xa0030000 {
	compatible = "nvidia,tegra186-ivcc";
	nvidia,notifications = <&hsp_top
		TEGRA_HSP_PROC_FOO
		TEGRA_HSP_DB_FOO>;
	#address-cells = <2>;
	#size-cells = <2>;
	ranges;
	ivcc-chan1: ivcc-chan@0xa0030100 {
		reg = <0 0xa0030100 0 0x400>,
		      <0 0xa0040100 0 0x400>;
		nvidia,frame-size = <64>;
	};

	ivcc-chan2: ivcc-chan@0xa0030500 {
		reg = <0 0xa0030500 0 0x400>,
		      <0 0xa0040500 0 0x400>;
		nvidia,frame-size = <64>;
	};
};

== Clients ==
Clients that use IVC channels must define below property in its node:

- nvidia,ivcc-channels: a list of channel phandles pointing to the
  nodes representing the desired IVC channels.

Example:

    some_device {
	nvidia,ivcc-channels = <&ivcc-chan1>, <&ivcc-chan2>;
    };
